\section{Processi primari}
\label{sec:processi_primari}

\subsection{Fornitura}
\label{sub:fornitura}

\subsubsection{Descrizione}

Il processo di fornitura aggrega diverse attività con l'obiettivo da parte del gruppo di candidarsi come fornitori del prodotto
\emph{HD Viz}.
Il processo di fornitura consiste delle seguenti attività:
\begin{itemize}
    \item \textbf{Studio di fattibilità};
	\item \textbf{Piano di Progetto};
	\item \textbf{Piano di Qualifica}.
\end{itemize}

In questa sezione vengono descritte e trattate tutte le norme a cui il gruppo \emph{SpaghettiCode} intende attenersi
durante il processo di fornitura, con lo scopo di diventare i fornitori del prodotto \emph{HD Viz} del
\glossario{proponente} \emph{Zucchetti S.p.A.} e dei committenti \emph{prof. Tullio Vardanega} e
\emph{prof. Riccardo Cardin}.

\subsubsection{Studio di Fattibilità}
\label{par:studio_fattibilita}

In seguito alla presentazione ufficiale dei diversi capitolati d'appalto, tenutasi in data 2020-11-05, i vari componenti
del gruppo esprimono i propri interessi e dubbi in merito ai diversi capitolati.
Dopo aver deciso la prima scelta del gruppo tra i vari capitolati disponibili, gli \emph{analisti}
raccolgono ed analizzano meglio i punti di forza e le criticità emersi nei diversi capitolati e riportano quanto
riscontrato nel documento \textsc{Studio Di Fattibilità}, fornendo così le motivazioni che hanno spinto il gruppo
\emph{SpaghettiCode} a proporsi o meno come \glossario{fornitore} di uno specifico capitolato. Questo documento è il
prodotto dell'omonima attività, la quale è strutturata come segue:
\begin{itemize}
    \item \textbf{Raccolta di informazioni generali}: si raccolgono tutte le informazioni basilari riguardanti il
    capitolato che comprendono nome, proponente e committente;
    \item \textbf{Comprensione delle caratteristiche}: si studiano e comprendono le caratteristiche del prodotto che
    deve essere sviluppato;
    \item \textbf{Comprensione dello scopo del progetto}: si studiano e comprendono i possibili fini del progetto;
    \item \textbf{Comprensione delle tecnologie interessate}: si studia e si determina quali siano le tecnologie
    interessate dal capitolato, se imposte o suggerite dal proponente;
    \item \textbf{Valutazione degli aspetti positivi}: vengono individuati gli aspetti positivi di ogni capitolato;
    \item \textbf{Valutazione dei rischi}: vengono individuati tutti i possibili rischi del capitolato proposto;
    \item \textbf{Conclusioni}: vengono ponderati gli aspetti positivi e gli aspetti negativi del capitolato, traendo
    quindi le conclusioni in merito alla fattibilità.
\end{itemize}

\subsubsection{Piano di Progetto}
\label{par:pdp}

Il gruppo deve pianificare come si svolgerà il progetto e considerare le tempistiche con cui ogni altra attività verrà
eseguita. Quest'attività si formalizza nell'omonimo documento, redatto dagli \emph{amministratori}, sotto la
supervisione del \emph{\glossario{responsabile di progetto}}. Vista la continua evoluzione del piano di progetto anche
il relativo documento deve essere redatto e aggiornato per tutta la durata del progetto. La sua struttura è la seguente:
\begin{itemize}
    % TODO: what?
    \item \textbf{Analisi dei rischi}: sezione in cui vengono analizzati i rischi che possono presentarsi nel corso del
    progetto; vengono inoltre fornite le modalità con cui vengono risolti o ridimensionati. Un'analisi più esaustiva
    si troverà nel documento \glossario{Analisi dei requisiti};
    \item \textbf{\glossario{Modello di sviluppo}}: sezione in cui viene descritto il \glossario{modello di sviluppo}
    scelto dal gruppo e le motivazioni che hanno portato a scegliere quel determinato modello;
    \item \textbf{Pianificazione}: vengono descritte e pianificate le attività da eseguire nelle vari fasi del progetto,
    stabilendo i termini temporali (\glossario{deadline}) per il loro completamento. Queste deadline non sono però
    rigide perché, come accennato prima, la pianificazione sarà sempre soggetta a modifiche e/o aggiornamenti;
    \item \textbf{Preventivo e consuntivo}: viene stimata la quantità di lavoro necessaria per ogni processo del
    \glossario{ciclo di vita} del progetto. Viene quindi esposto un \glossario{preventivo} e un successivo
    \glossario{consuntivo}, entrambi relativi ad un dato periodo.
\end{itemize}

\subsubsection{Piano di Qualifica}

La presente attività raccoglie tutte le regole e le linee guida per garantire che i materiali prodotti rispettino
determinati standard di qualità. Questo insieme di regole deve essere, come per il piano di progetto, formalizzato
nell'omonimo documento redatto dai \emph{verificatori}.
Questo documento è strutturato nel seguente modo:
\begin{itemize}
    \item \textbf{Qualità di processo}: sono individuati i processi dagli \glossario{standard di processo}, definiti
    degli obiettivi, strategie per attuarli e \glossario{metriche} per controllarli e misurarli;
    \item \textbf{Qualità di prodotto}: vengono individuate le caratteristiche più importanti del prodotto, gli
    obiettivi necessari per raggiungerle e le metriche per misurarle;
    \item \textbf{Specifiche dei test}: vengono definiti dei \glossario{test} che il prodotto deve superare per
    garantire il soddisfacimento dei requisiti;
    \item \textbf{Standard di qualità}: descritti gli \glossario{standard di qualità} selezionati;
    \item \textbf{Resoconto delle attività di verifica}: vengono esposti i risultati dei test eseguiti durante il
    periodo di revisione; le metriche usate per l'ottenimento di questi risultati sono redatte nel documento;
    \item \textbf{Lista di controllo}:  lista che contiene gli errori riscontrati (sezione in continua fase di
    aggiornamento per l'intera durata del progetto);
    \item \textbf{Valutazioni per il miglioramento}: vengono elencati i problemi riscontrati durante lo sviluppo del
    progetto e vengono proposte delle soluzioni che potrebbero portare alla risoluzione o alla mitigazione degli stessi.
\end{itemize}
In questo documento si fa uso di un codice identificativo dei rischi. Il codice avrà questa forma:
\begin{center}
	\textbf{[Tipologia][Codice]}
\end{center}
Dove:
\begin{itemize}

	\item \textbf{Tipologia}: indica la tipologia di rischio e può assumere tre valori:
	\begin{itemize}
		\item \textbf{RR}: indica un rischio legato ai requisiti;
		\item \textbf{RT}: indica un rischio legato alle tecnologie;
		\item \textbf{RO}: indica un rischio legato all'organizzazione.
	\end{itemize}
    \item \textbf{Codice}: Il codice è un numero progressivo univoco all'interno della tipologia, che permette di
    identificare univocamente il rischio.
\end{itemize}

Ogni rischio avrà, oltre al codice, due informazioni:
\begin{itemize}
	\item \textbf{Occorrenza}: indica a frequenza con cui occorre il rischio;
	\item \textbf{Gravità}: indica la gravità del rischio.
\end{itemize}

\subsection{Sviluppo}
\label{sub:sviluppo}

\subsubsection{Descrizione}
\label{ssub:sviluppo:descrizione}
% TODO: aggiungere integrazione, test, installazione e accettazione

Il processo di sviluppo racchiude al suo interno un insieme di attività le quali hanno come obiettivo comune la produzione corretta ed
efficace del prodotto software di cui si è fornitori. Le attività che verranno svolte durante l'attuazione del processo in questione sono
le seguenti:
\begin{itemize}
	\item \textbf{Analisi dei Requisiti};
	\item \textbf{Progettazione};
	\item \textbf{Codifica}.
\end{itemize}
Vengono di seguito definite le regole e norme a cui il gruppo aderirà durante lo svolgersi delle diverse attività.

\subsubsection{Analisi dei requisiti}
\label{ssub:analisi}

\paragraph{Scopo}
\label{par:analisi:scopo}

Lo scopo dell'analisi dei requisiti è quello di individuare e stabilire le caratteristiche del prodotto di comune accordo con il proponente.
L'attività viene svolta da parte degli \emph{analisti}, prende in ingresso la definizione del problema e produce il documento
\textsc{Analisi dei Requisiti}, che funge da vincolo contrattuale tra fornitore e proponente, all'interno del quale vengono definite
le funzionalità che il prodotto deve offrire e vengono specificati i requisiti che deve soddisfare.

I principali compiti dell'attività sono i seguenti:
\begin{itemize}
	\item individuazione delle funzionalità;
	\item definizione dei requisiti.
\end{itemize}

Le funzionalità del prodotto vengono rappresentate mediante i casi d'uso e sono ricavate dalle seguenti fonti:
\begin{itemize}
    \item \textbf{Capitolato d'appalto}: prima descrizione del prodotto messa a disposizione dal proponente;
    \item \textbf{Dominio del problema}: ambito nel quale rientra il problema;
    \item \textbf{Incontri interni}: discussioni interne tra i membri del gruppo;
    \item \textbf{Incontri esterni}: discussioni dei membri del gruppo con il proponente o con i committenti.
\end{itemize}
Le funzionalità inoltre svolgono funzione di supporto per i requisiti, oltre ad essere
di chiara comprensione anche per persone non esperte del settore informatico.

I requisiti sono invece il punto centrale dell'attività, essi possono essere ricavati dalle seguenti fonti:
\begin{itemize}
    \item \textbf{Capitolato d'appalto}: prima descrizione del prodotto messa a disposizione dal proponente;
    \item \textbf{Casi d'uso}: funzionalità del prodotto;
    \item \textbf{Incontri interni}: discussioni interne tra i membri del gruppo;
    \item \textbf{Incontri esterni}: discussioni dei membri del gruppo con il proponente o con i committenti.
\end{itemize}

I requisiti in particolare hanno le seguenti finalità:
\begin{itemize}
    \item Fissare oggettivamente le caratteristiche del prodotto concordate con il cliente;
    \item Fornire le indicazioni necessarie ai \emph{progettisti};
    \item Dare ai \emph{verificatori} indicazioni per svolgere le attività di controllo;
    \item Dare dei riferimenti per poter effettuare una stima accurata del lavoro necessario.
\end{itemize}

\paragraph{Classificazione dei casi d'uso}
\label{par:classificazione_casi_duso}

Ogni caso d'uso ha una struttura ben definita, riportata di seguito:
\begin{itemize}
    \item \textbf{Descrizione}: breve descrizione del caso d'uso;
    \item \textbf{Attore primario}: entità che interagisce direttamente con il prodotto;
    \item \textbf{Attori secondari}: entità che supportano l'attore primario nel portare a termine il caso d'uso in
    	esame (questo elemento non è necessariamente presente);
    \item \textbf{Precondizione}: condizione del sistema necessaria affinché possa compiersi il caso d'uso in esame;
    \item \textbf{Postcondizione}: condizione in cui si trova il sistema immediatamente dopo il compimento del caso
    d'uso in esame;
    \item \textbf{Scenario principale}: rappresentazione del flusso degli eventi previsti dal caso d'uso;
    \item \textbf{Scenari alternativi}: rappresentazioni alternative del flusso degli eventi del caso d'uso (questo
    	elemento non è necessariamente presente);
    \item \textbf{Estensioni}: elemento che indica casi d'uso eseguiti condizionatamente che determinano l'interruzione
    	dell'esecuzione del caso d'uso in esame (questo elemento non è necessariamente presente);
    \item \textbf{Inclusioni}: elemento che indica casi d'uso eseguiti incondizionatamente successivamente a quello in
    	esame (questo elemento non è necessariamente presente);
    \item \textbf{Generalizzazioni}: rappresentano delle possibili specializzazioni del caso d'uso (questo elemento non è necessariamente
    	presente).
\end{itemize}

Inoltre per chiarezza e manutenibilità a ciascun caso d'uso viene associato un codice immutabile che lo identifica univocamente
all'interno del progetto. Tale codice si presenta nella seguente forma:
\begin{center}
    \textbf{UC([Sistema])[CodiceBase](.[CodiceSottoCaso])*}
\end{center}
dove \textbf{Sistema} indica dove ha luogo il caso d'uso, nel caso non sia specificato si assume che il sistema sia la Web app
\emph{HD Viz}, altrimenti il campo può assumere i seguenti valori:
\begin{itemize}
	\item \textbf{S}: il caso d'uso ha luogo nel server di \emph{HD Viz}.
\end{itemize}
\textbf{CodiceBase} è un intero positivo che distingue i casi d'uso, relativi allo stesso sistema, rispetto al primo livello di
granularità; \textbf{CodiceSottoCaso} invece è un intero positivo che distingue i casi d'uso relativi allo stesso sistema rispetto ai
livelli di granularità successivi nel caso siano presenti.

\paragraph{Classificazione dei requisiti}
\label{par:classificazione_requisiti}

I requisiti sono composti dai seguenti elementi:
\begin{itemize}
	\item \textbf{Descrizione}: descrizione chiara del requisito in esame;
	\item \textbf{Importanza}: rilevanza di un requisito rispetto alle esigenze del prodotto;
	\item \textbf{Fonte}: riferimento univoco alla fonte dalla quale il requisito è stato individuato (capitolato d'appalto, caso d'uso,
		verbali interni o verbali esterni).
\end{itemize}

Inoltre ciascun requisito viene associato ad un codice immutabile che lo identifica univocamente che si presenta nella seguente forma:
\begin{center}
    \textbf{R[Tipologia][Importanza][Codice]}
\end{center}

Questa notazione, spiegata nel dettaglio di seguito, permette di identificare in modo univoco ogni requisito del prodotto.
\begin{itemize}
    \item \textbf{Tipologia}: permette di identificare la tipologia del requisito e i possibili valori che può assumere sono:
    \begin{itemize}
        \item \textbf{V}: indica che è un requisito di vincolo, ossia una condizione imposta dal proponente circa i servizi offerti dal
        	prodotto software all'utilizzatore finale;
        \item \textbf{F}: indica che è un requisito funzionale, cioè un vincolo riguardo le funzioni del prodotto;
        \item \textbf{P}: indica che è un requisito prestazionale, ossia specifica delle condizioni sulle prestazioni del prodotto software;
        \item \textbf{Q}: indica che è un requisito di qualità, quindi pone dei vincoli sulla qualità del prodotto.
    \end{itemize}
    \item \textbf{Importanza}: permette di individuare quale sia la rilevanza del requisito ed i suoi possibili valori sono:
    \begin{itemize}
        \item \textbf{O}: indica che il requisito è obbligatorio, quindi questo requisito dovrà essere necessariamente
        soddisfatto;
        \item \textbf{D}: indica che il requisito è desiderabile, quindi eventualmente negoziabile con il proponente.
        Il soddisfacimento del requisito verrebbe visto positivamente dal proponente, in quanto fornirebbe al prodotto
        una maggiore completezza, eppure non ne viene vincolata l'implementazione;
        \item \textbf{F}: indica che il requisito è facoltativo, dunque anche se porta un valore aggiunto al prodotto
        comporta una piccola miglioria a dispendio di molto tempo e lavoro.
    \end{itemize}

    \item \textbf{Codice}: permette di distinguere i requisiti appartenenti alla stessa tipologia e si presenta nella forma
    	\begin{center}
        	\textbf{[CodiceBase](.[CodiceSottoCaso])*}
    	\end{center}
    	dove \textbf{CodiceBase} e \textbf{CodiceSottoCaso} sono interi positivi ed essi permettono di correlare e distinguere i requisiti
    	specificando diversi livelli di granularità.
\end{itemize}

\subsubsection{Progettazione}
\label{ssub:progettazione}

\paragraph{Scopo}
\label{par:progettazione:scopo}

Lo scopo di quest'attività è quello di individuare le caratteristiche che il prodotto deve avere per soddisfare nel
modo migliore possibile le richieste del proponente in risposta ai requisiti individuati dall'analisi dei requisiti. \\
In quest'attività bisogna rispettare i seguenti vincoli:
\begin{itemize}
    \item Garantire la qualità del prodotto seguendo un principio di correttezza costruttivo;
    \item Organizzare e suddividere i compiti in modo da diminuire la complessità del problema, riducendolo via via in
    sottoproblemi sempre più elementari fino ad arrivare ai singoli componenti;
    \item Ottimizzare l'uso di risorse.
\end{itemize}

La progettazione è divisa in due parti fondamentali:
\begin{itemize}
    \item \glossario{Technology Baseline}: contiene le specifiche ad alto livello della progettazione del software,
    i relativi diagrammi \glossario{UML} e dei test;
    \item \glossario{Product Baseline}: arricchisce di dettagli quanto specificato nella Technology baseline e
    definisce i test necessari.
\end{itemize}

\paragraph{Aspettative}

La progettazione è un'attività svolta dai \emph{Progettisti}, volta a produrre l'architettura logica del prodotto.
L'architettura deve essere formata da componenti chiari, riusabili e utilizzabili in modo che ci sia coesione tra
le parti.\\
L'architettura dovrà necessariamente rispettare i seguenti punti:
\begin{itemize}
    \item Soddisfare i requisiti individuati dall'analisi dei requisiti;
    \item Adattarsi in caso i requisiti evolvano;
    \item Riuscire a gestire situazioni erronee;
    \item Risultare affidabile anche in situazioni sfavorevoli come temporanee mancanze;
    \item Garantire un certo livello di sicurezza rispetto ai malfunzionamenti;
    \item Presentare solo il minimo intervallo possibile di indisponibilità durante i periodi di manutenzione;
    \item Impiegare efficientemente le risorse;
    \item Garantire la riusabilità delle sue parti anche in altri applicativi;
    \item Presentare componenti semplici e con basso livello di accoppiamento.
\end{itemize}

\paragraph{Design pattern}

La scelta dei \glossario{design pattern} da utilizzare è lasciata ai \emph{progettisti}, i quali dovranno
assicurarsi che le loro scelte portino a una soluzione che sia flessibile e lasci una certa libertà ai
\emph{programmatori}. Ogni design pattern utilizzato andrà spiegato e rappresentato in modo da poterne esporre
significato e struttura.

\paragraph{Diagrammi UML}
\label{par:progettazione:diagrammi_UML}
È stato scelto di utilizzare diagrammi UML allo scopo di rendere più chiare le scelte compiute in ambito di
progettazione. Tra questi spiccano i diagrammi delle attività e quelli di sequenza. I primi vengono
usati per descrivere il flusso di operazioni di un'attività, i secondi per illustrare sequenze di azioni.\\
Ci potranno essere, oltre ai due tipi già menzionati, diagrammi di altro tipo se i \emph{progettisti} lo riterranno
utile.\\
Il gruppo ha deciso di aderire allo standard UML 2.0 presentato a lezione per la stesura dei diagrammi. Ogni eventuale
distacco dallo standard necessario per le limitazioni dei software per la creazione di diagrammi UML o al fine di ridurre
eventuali incomprensioni, dovranno essere normati nelle sezioni di riferimento nel presente documento.

\subparagraph{Diagrammi di attività}
\label{ssub:progettazione:diagrammi_UML:diagrammi_di_attivita}
I diagrammi di attività sono redatti secondo quanto spiegato nella lezione E2 e quanto riportato nelle slide
\emph{Diagrammi di Attività}.
I diagrammi di attività dovranno analizzare attività piccole, al fine di semplificare la manutenzione e ridurre il numero
di modifiche.
\end{enumerate}

\subparagraph{Diagrammi delle classi}
\label{ssub:progettazione:diagrammi_UML:diagrammi_delle_classi}
I diagrammi delle classi sono redatti secondo quanto spiegato nella lezione E1 e quanto riportato nelle slide
\emph{Diagrammi delle classi}.\\
Al fine di migliorare la leggibilità dei diagrammi delle classi,  sarà necessario inserire esplicitamente all'interno di
una classe soltamente gli attributi di tipo primitivo. Nel caso una classe contenga attributi di tipo non primitivo,
allora sarà necessario modellare questi attributi mediante associazione tra classi.\\
UML permette di inserire all'interno dei diagrammi dei commenti. Poichè il codice dovrebbe già essere leggibile ed
autoesplicativo, al fine di ridurre il carico di lavoro necessario per mantenere la consistenza tra i commenti nei
diagrammi e i commenti nel codice si decide di commentare nei diagrammi UML \emph{soltamente} le API esposte
dall'applicativo e solo se ritenuto strettamente necessario.
\end{enumerate}

\subparagraph{Diagrammi di package}
\label{ssub:progettazione:diagrammi_UML:diagrammi_di_package}
I diagrammi di attività sono redatti secondo quanto spiegato nella lezione E1 e quanto riportato nelle slide
\emph{Diagrammi di Package}.
\end{enumerate}

\subparagraph{Diagrammi di sequenza}
\label{ssub:progettazione:diagrammi_UML:diagrammi_di_sequenza}
I diagrammi di attività sono redatti secondo quanto spiegato nella lezione E2 e quanto riportato nelle slide
\emph{Diagrammi di sequenza}.


\paragraph{Test}

Come specificato precedentemente, la definizione dei test è parte integrante dell'attività di progettazione in quanto ne garantisce le
caratteristiche qualitative, quindi ogni \emph{progettista} dovrà affiancare alla progettazione del sistema la definizione dei relativi test.

\subsubsection{Codifica}
\label{ssub:codifica}

\paragraph{Scopo}
\label{par:codifica:scopo}

L'attività di codifica viene svolta da parte dei \emph{programmatori} ed ha il compito di tradurre l'architettura logica, mantenendo gli
standard qualitativi imposti e descritti all'interno del \textsc{Piano di Qualifica}, nel prodotto software. Di seguito vengono presentate
le regole e le norme che il gruppo pone sull'attività al fine di garantire la leggibilità del codice e di agevolarne manutenzione,
verifica e validazione.

\paragraph{Regole generali di codifica}
\label{par:stile_codifica}

Al fine di garantire uniformità nel codice prodotto, si è deciso di stabilire delle regole nella scrittura del codice; in generale, a
prescindere dal tipo di file sorgente, valgono le seguenti norme:
\begin{itemize}
	\item Encoding: tutti i file sorgenti devono essere in codifica \glossario{UTF-8};
    \item Indentazioni: i blocchi di codice annidati, commenti esclusi, devono presentare 4 spazi di rientro rispetto al livello precedente;
    \item Righe: ciascuna riga può contenere al massimo 140 caratteri;
    \item Wrapping: nel caso una riga contenga più di 140 caratteri essa deve essere suddivisa su più linee di modo che rispettino tutte
    	la lunghezza massima e le righe aggiunte devono essere indentate di due livelli rispetto alla riga originale;
    \item Lingua: la lingua utilizzata per i nomi delle variabili e dei metodi deve essere l'inglese.
\end{itemize}



\paragraph{Linee guida JavaScript}
\label{par:convenzioni_javascript}

Di seguito vengono specificate le linee guida per la codifica di codice JavaScript:
\begin{itemize}
	\item \textbf{Intestazione:} \\
		ciascun file sorgente JavaScript deve contenere la seguente intestazione specificando gli opportuni valori
		\begin{lstlisting}[style=htmlcssjs]
			/**
	 	 	 * @file <Descrizione del file>
	 	 	 *
	 	 	 * @file           <Descrizione del file>
	 	 	 *
	 	 	 * Data Creazione: <Data di creazione>
	 	 	 *
	 	 	 * @version        <Versione prodotto>
	 	 	 * @author         SpaghettiCode
	 	 	 * @author         <Nome Cognome>
	 	 	 * [@author        <Nome Cognome>]
	 	 	 */
		\end{lstlisting}
		seguendo le norme in \refSec{par:date} e \refSec{par:codice_versione} rispettivamente per il formato della data e il codice di versione;
	\item \textbf{Intestazione funzioni:} \\
		ciascuna funzione e/o metodo dev'essere preceduta dalla seguente intestazione specificando opportunamente i valori
		\begin{lstlisting}[style=htmlcssjs]
			/**
			 * <Descrizione della funzione>
			 *
			 * [@param {<tipo parametro>} <Nome parametro> - <Descrizione parametro>]
			 */
		\end{lstlisting}
\end{itemize}

\subparagraph{Convenzioni sui nomi}

Ciascun elemento deve avere un nome espressivo che esprima chiaramente che cosa rappresenta, in modo da migliorare la leggibilità e
semplificare la manutenzione.

Di seguito vengono elencate le regole per l'assegnazione dei nomi di diversi componenti.
\begin{itemize}
	\item \textbf{Classi}:\\
		i nomi di classi, interfacce e record devono seguire la convenzione \glossario{PascalCase} \\
        \begin{lstlisting}[style=htmlcssjs]
			class Foo {
			...
			}
		\end{lstlisting}

    \item \textbf{Metodi}:\\
    	i nomi dei metodi devono seguire la convenzione \glossario{CamelCase}, inoltre i metodi che ritornano valori booleani devono avere il
    	nome che comincia per \texttt{is} e deve essere indicativo del loro comportamento\\
		\begin{lstlisting}[style=htmlcssjs]
			class Foo {
				fooMethod() {
				...
				}

				isTrue() {
					return true;
				}
			}
		\end{lstlisting}

	\item \textbf{Costanti}:\\
		i nomi delle costanti, ossia degli elementi che non possono cambiare stato, seguono la convenzione
		\glossario{CONSTANT\_CASE} \\
		\begin{lstlisting}[style=htmlcssjs]
			const MEANING_OF_LIFE = 42;
		\end{lstlisting}

    \item \textbf{Variabili}:\\
		i nomi delle variabili devono seguire la convenzione CamelCase \\
		\begin{lstlisting}[style=htmlcssjs]
			let correctVariableName = true;
			let correct = true;
		\end{lstlisting}

	\item \textbf{Funzioni}:\\
		i nomi delle funzioni devono seguire la convenzione CamelCase \\

		\begin{lstlisting}[style=htmlcssjs]
			function fooBar() {
			...
			}
		\end{lstlisting}
	\item \textbf{Parametri}:\\
		i nomi dei parametri devono seguire la convenzione CamelCase \\

		\begin{lstlisting}[style=htmlcssjs]
			function sum(firstNumber, secondNumber) {

			}
		\end{lstlisting}

	\end{itemize}

\subparagraph{Formattazione}

La formattazione del codice deve rendere immediata l'identificazione degli elementi e di conseguenza dev'essere incentrata sull'espressività
rispetto alla sinteticità.
Di seguito vengono elencate le regole per quanto riguarda la formattazione del codice:
\begin{itemize}
	\item \textbf{Parentesi}:\\
		tutte le strutture di controllo (\texttt{if}, \texttt{else}, \texttt{for}, \texttt{do}, \texttt{while}), anche se contenenti
		un'unica istruzione, devono essere provviste delle parentesi graffe.\\

		L'unica eccezione si ha con il costrutto \texttt{if} definito \emph{inline}\\

		\begin{lstlisting}[style=htmlcssjs]
			if (isTrue()) {
				foo();
				bar();
			} else {
				fooBar();
			}

			if (isTrue()) fooBar();
		\end{lstlisting}

	\item \textbf{Blocchi}:\\
		per quanto riguarda i blocchi di codice l'apertura di un blocco non dev'essere preceduta da un carattere di interruzione di linea
		mentre si deve andare a capo dopo l'apertura del blocco e prima della chiusura di un blocco;
		\begin{lstlisting}[style=htmlcssjs]
			function isRightBlock() {
				return true;
			}
		\end{lstlisting}

	\item \textbf{Istruzioni}:\\
		ciascuna istruzione dev'essere terminata dal punto e virgola e deve essere seguita da un'interruzione di linea.

	\item \textbf{Spazi bianchi}:\\
		nelle assegnazioni e all'interno delle espressioni si devono inserire spazi tra gli elementi e gli operatori.
		\begin{lstlisting}[style=htmlcssjs]
			let expression = firstNumber + secondNumber * secondNumber;
		\end{lstlisting}
\end{itemize}

\subparagraph{Commenti}
\label{ssub:codifica:commenti}
Linea guida a cui attenersi per scrivere codice di qualità è quella di commentare il codice scritto.
Ogni blocco di codice (classe, metodo, ecc..) potrà essere immediatamente preceduto, se ritenuto necessario, da un commento che ne descriva
\emph{sinteticamente} il funzionamento, gli eventuali parametri e i risultati aspettati.
I test sono codice di produzione e come tale, dovranno essere scritti e commentati in modo da soddifare i requisiti di qualità richiesti.
Per fare chiarezza ed aumentare la manutenibilità del sorgente, è importante che ci siano di commenti in riga che vadano a documentare il
comportamento delle singole istruzioni, se ritenuto opportuno.\\
Se per descrivere il comportamento di una singola riga di codice risulta necessario
scrivere più di qualche parola, sarà il caso di spostare il commento sopra la riga, e trattarlo come un.
\begin{lstlisting}[style=htmlcssjs]
    /**
    * un'amichevole funzione foo
    */
    function foo() {
        ...
        a = b; //a assume il valore di b
        ...
        /**
        * Corretto descrivere la seguende condizione qui
        */
        if (a||b && a||c != b && c) { //Potrebbe risultare difficile riassumere una condizione complessa in poche parole.
            ...
        }
    }
\end{lstlisting}


\subparagraph{Funzionalità del linguaggio}

Alcune funzionalità peculiari del linguaggio sono preferibili ad altre nella codifica di software di qualità, pertanto di seguito vengono
specificati i costrutti del linguaggio consentiti:
\begin{itemize}
	\item \textbf{Variabili locali}:\\
		per la definizione delle variabili vengono utilizzati i costrutti \texttt{const} e \texttt{let}; il costrutto \texttt{var} va
		evitato in modo da poter gestire in maniera migliore lo \emph{scope} delle variabili;

	\item \textbf{Classi}:\\
		per comodità di verifica viene preferito l'uso del costrutto \texttt{class} rispetto alla definizione di classi anonime \\
		\begin{lstlisting}[style=htmlcssjs]
			class MyClass {
			...
			}
		\end{lstlisting}

	\item \textbf{Funzioni}:\\
		per comodità di verifica viene preferita la definizione di funzioni esplicite rispetto alla definizione di funzioni anonime \\
		\begin{lstlisting}[style=htmlcssjs]
			function myFunction(foo, bar) {
			...
			}
		\end{lstlisting}

	\item \textbf{Funzioni anonime}:\\
		qualora fosse necessario implementare funzioni anonime viene preferito l'utilizzo dell'operatore \emph{freccia}
		\begin{lstlisting}[style=htmlcssjs]
			(foo, bar) => {
			...
			}
		\end{lstlisting}


	\item \textbf{Letterali}:\\
		nell'istanziazione di \texttt{Object} e/o \texttt{Array} preferire l'utilizzo dei letterali rispetto ai costruttori
		\begin{lstlisting}[style=htmlcssjs]
			let myArray = [];
			let myObject = {};
		\end{lstlisting}

	\item \textbf{Operatore di espansione}:\\
		per riferirsi agli elementi di un array preferire l'utilizzo dell'operatore di espansione rispetto a costrutti più onerosi;

	\item \textbf{Confronti}:\\
		nel caso di confronti utilizzare gli operatori di identità (\texttt{===} e \texttt{!==}) anziché quelli di confronto.
\end{itemize}

\paragraph{Linee guida HTML}
\label{par:convenzioni_html}

Di seguito vengono elencate le regole che dovranno essere adottate nello sviluppo di file HTML:
\begin{itemize}
	\item \textbf{Dichiarazione DOCTYPE}:\\
		la prima linea di ciascun file deve contenere la dichiarazione del tipo di documento come segue\\
		\begin{lstlisting}[style=html]
			<!DOCTYPE html>
		\end{lstlisting}
	\item \textbf{Dichiarazione encoding}:\\
		all'interno della sezione head dev'essere presente un tag meta che specifichi l'encoding del file
		\begin{lstlisting}[style=html]
			<meta charset="utf-8">
		\end{lstlisting}
	\item \textbf{Tag}:\\
		i tag ed i nomi degli attributi devono essere esclusivamente in minuscolo;
	\item \textbf{Attributi}:\\
		i valori degli attributi vanno racchiusi all'interno dei doppi apici
		\begin{lstlisting}[style=html]
			<a class="class-value"></a>
		\end{lstlisting}
	\item \textbf{Id e classi}:\\
		i valori degli id e delle classi devono privilegiare l'espressività e seguire la convenzione \glossario{kebab-case}
		\begin{lstlisting}[style=html]
			<a id="id-value" class="class-value">Foo</a>
		\end{lstlisting}
\end{itemize}

\subsubsection{Strumenti}

Sono riportati di seguito gli strumenti utilizzati nel processo di sviluppo:
\begin{itemize}
	\item \textbf{Draw.io}: applicazione web molto versatile per disegnare grafici UML che offre la possibilità di lavorare
		contemporaneamente;
	\item \textbf{HTML}: linguaggio utilizzato per lo sviluppo di pagine web utilizzato per specificare la struttura della pagina;
	\item \textbf{CSS}: linguaggio utilizzato nello sviluppo di pagine web per gestire e personalizzare la presentazione;
	\item \textbf{JavaScript}: linguaggio di scripting per web application richiesto dal proponente che fornisce la possibilità di
		utilizzare la libreria D3.js;
	\item \textbf{D3.js}: libreria open source scritta in \emph{JavaScript} con lo scopo di facilitare la visualizzazione dei dati in
		grafici, è lo strumento principale per la realizzazione del prodotto HD Viz.
\end{itemize}
